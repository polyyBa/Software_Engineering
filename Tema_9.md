# Тема 9. ООП на Python: концепции, принципы и примеры реализации.
Отчет по Теме #9 выполнила:
- Баталова Полина Андреевна
- ПИЭ-21-1
  
| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | 
| Задание 3 | + | 
| Задание 4 | + | 
| Задание 5 | + | 

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию  init (), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python 
class Ivan:
    __slots__ = ['name']

    def __init__(self, name):
        if name == 'Иван':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"

person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)

person2.surname = 'Петров'
```

### Результат
![image](https://github.com/polyyBa/Software_Engineering/assets/144797777/1462a7cc-2042-43e1-92ab-d480dd5c4391)

## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе  реализуйте  метод,  выводящий  на  печать  «Мороженое  с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

```python 
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print('Обычное мороженое')

icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```

### Результат
![image](https://github.com/polyyBa/Software_Engineering/assets/144797777/f1d1ef80-c7b8-4c75-a218-91fde42aa7a8)

## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value

    def get_value(self):
        return self._value

    def del_value(self):
        del self._value

    value = property(get_value, set_value, del_value, "Свойство value")

odj = MyClass(42)
print(odj.get_value())
odj.set_value(45)
print(odj.get_value())
odj.set_value(100)
print(odj.get_value())
odj.del_value()
print(odj.get_value())
```

### Результат
![image](https://github.com/polyyBa/Software_Engineering/assets/144797777/b07f83ee-2490-4166-8504-b20daf2303b7)

## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

```python
class Mammal:
    className = 'Mammal'

class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
```

### Результат
![image](https://github.com/polyyBa/Software_Engineering/assets/144797777/451344a5-fab8-4cca-bc81-a57f9f78d82d)

## Лабораторная работа №5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")

class English:
    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)
```

### Результат
![image](https://github.com/polyyBa/Software_Engineering/assets/144797777/d8cfd277-08d1-4b17-90dd-d493b3263d29)

## Самостоятельная работа 
### Задание Садовник и помидоры

### Классовая структура:
### Есть Помидор со следующими характеристиками:
### •	Индекс
### •	Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)
### Помидор может:
### •	Расти (переходить на следующую стадию созревания)
### •	Предоставлять информацию о своей зрелости
### Есть Куст с помидорами, который:
### •	Содержит список томатов, которые на нем растут А также может:
### •	Расти вместе с томатами
### •	Предоставлять информацию о зрелости всех томатов
### •	Предоставлять урожай
### И также есть Садовник, который имеет:
### •	Имя
### •	Растение, за которым он ухаживает Он может:
### •	Ухаживать за растением
### •	Собирать с него урожай

## Задание:
### Класс Tomato:
### 1)	Создайте класс Tomato
### 2)	Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
### 3)	Создайте метод	init	(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state (принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
### 4)	Создайте метод grow(), который будет переводить томат на следующую стадию созревания
### 5)	Создайте метод is_ripe(), который будет проверять, что томат созрел 
## Класс TomatoBush:
### 1)	Создайте класс TomatoBush
### 2)	Определите метод	init	(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes
### 3)	Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
### 4)	Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.
### 5)	Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая
### Класс Gardener:
### 1)	Создайте класс Gardener
### 2)	Создайте метод	init	(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
### 3)	Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
### 4)	Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
### 5)	Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству
### Тесты:
### 1)	Вызовите справку по садоводству
### 2)	Создайте объекты классов TomatoBush и Gardener
### 3)	Используя объект класса Gardener, поухаживайте за кустом с помидорами
### 4)	Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
### 5)	Соберите урожай
### Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполенния всех тестов.

```python
# Создаем класс Tomato
class Tomato:
    # Создаем статическое свойство states
    states = {'Отсутствует': 0, 'Цветение': 1, 'Зеленый': 2, 'Красный': 3}

    # Создаем метод init
    def __init__(self, index):
        # Динамическое свойство _index
        self._index = index
        # Динамическое свойство _state
        self._state = self.states['Отсутствует']  # Изначальное состояние - зеленый

    # Создаем метод grow
    def grow(self):
        if self._state == self.states['Красный']:  # Если томат красный - не переводим
            pass
        elif self._state == self.states['Зеленый']:
            self._state = self.states['Красный']
        elif self._state == self.states['Цветение']:
            self._state = self.states['Зеленый']
        else:
            self._state = self.states['Цветение']

    # Создаем метод is_ripe
    def is_ripe(self):
        return self._state == self.states['Красный']


# Создаем класс TomatoBush
class TomatoBush:

    # Определяем метод init
    def __init__(self, num):
        # Динамическое свойство tomatoes
        self.tomatoes = [Tomato(index) for index in range(1, num + 1)]

    # Создаем метод grow_all
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    # Создаем метод all_are_ripe
    def all_are_ripe(self):
        for tomato in self.tomatoes:
            if not tomato.is_ripe():
                return False
        return True

    # Создаем метод give_away_all
    def give_away_all(self):
        self.tomatoes = []


# Создаем класс Gardener
class Gardener:
    def __init__(self, name, plant):
        # Публичное войство name
        self.name = name
        # Динамическое свойство _plant
        self._plant = plant

    # Создаем метод work
    def work(self):
        self._plant.grow_all()

    # Создаем метод harvest
    def harvest(self):
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
            print("Урожай собран.")
        else:
            print("Плоды еще не дозрели.")

    # Создаем статический метод knowledge_base
    @staticmethod
    def knowledge_base():
        print("Справка по садоводству: ")
        print('1. Не забывайте регулярно поливать и подкармливать растения')
        print('2. Удаляйте поврежденные листья и плоды, чтобы предотвратить распространение болезней')


# Вызов справки по садоводству
Gardener.knowledge_base()

# Создаем объекты классов TomatoBush и Gardener
bush = TomatoBush(5)
gardener = Gardener('Иван', bush)

# Ухаживаем за помидорами
gardener.work()
gardener.work()
gardener.harvest()  # Плоды еще не дозрели

# Продолжаем ухаживать за помидорами
gardener.work()
gardener.work()
gardener.harvest()  # Урожай собран
```

### Результат 
![image](https://github.com/polyyBa/Software_Engineering/assets/144797777/b5c6012c-fe5c-4dfd-99c6-886368691239)

### Выводы

- Класс Tomato содержит свойства и методы для моделирования томата в различных состояниях, с возможностью роста и проверки зрелости.
- Также реализуется взаимодействие между состояниями томата с помощью метода grow и проверка зрелости с помощью метода is_ripe.
- Класс TomatoBush содержит методы для создания куста томатов (объектов класса Tomato), их роста и проверки, а также сбора урожая.
- Класс Gardener представляет собой объект, управляющий объектом TomatoBush. Включает методы для работы с растениями, сбора урожая и вывода справочной информации о садоводстве.
- С помощью метода knowledge_base объекта Gardener выводится справка по садоводству.
- Создаются объекты TomatoBush и Gardener с последующим управлением их методами.
- Показывается процесс работы с томатами, включающий их уход, проверку зрелости и сбор урожая. 
